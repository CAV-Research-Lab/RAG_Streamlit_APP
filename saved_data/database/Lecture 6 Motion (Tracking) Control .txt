=== Metadata ===
{
    "file_name": "Lecture 6 Motion (Tracking) Control .pdf",
    "file_path": "/Users/mf0016/Desktop/soe_RAG/resources/Lecture 6 Motion (Tracking) Control .pdf",
    "status": "Processed"
}

=== Content ===
Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah   Motion (Tracking) Control  Introduction to Motion Control To start, letâ€™s first answer the question: What Is Motion Control? The answer is: â€œMotion control, also known as tracking control, refers to the fact that a control system should be able to track the desired reference trajectory which is generated by motion planning module. In other words, the car should follow the reference trajectory as close as possible, with minimal transient and/or steady state error (zero in ideal case). In simpler words, Motion Control is how the intelligent car uses the steering, throttle, and breaks to drive where we want it to go. Control is a trickier problem than it might seem. When human turns through an intersection, we use our intuition and experience to determine how hard to steer, and when to accelerate, and whether we ever need to step on the brakes. Teaching a computer how to do this is hard. In this lecture, you'll learn how to implement a motion controller using different control systems.  First letâ€™s review what control methods that can be used for motion control. The controllers used for motion control or trajectory tracing can be classified as model-free and model-based controllers.  1. Model-Free Controllers: These controllers do not utilise any mathematical model of the system being controlled. Instead, they take 'corrective' action based on the 'error' between the setpoint and the current state. Such controllers are relatively easy to implement, as they do not require a deep understanding of the system's behaviour; however, they are difficult to tune, do not guarantee optimal performance, and tend to perform satisfactorily only under limited operating conditions. Common examples of these types of controllers include PID and Stanley controllers. 2. Model-Based Controllers: These controllers employ various types of mathematical models of the system being controlled. Typically, they offer optimal actions, are straightforward to tune, and are easy to implement. However, their practical operation is limited to certain driving and operational conditions due to sensitivity to parameter variations and model accuracy. Model-based controllers can be further classified as: Â§ Kinematic Controllers: These controllers utilise simplified motion models of the system, based on its geometry and kinematics, generally employing first-order approximations. They assume no slip or skip and often ignore internal or external forces acting on the system. Consequently, these types of controllers are typically limited to low-speed applications, where the system dynamics can be reasonably approximated. However, they offer the advantage of low computational complexity, which is extremely significant in real-world implementations as opposed to theoretical formulations or simulations. Â§ Dynamic Controllers: These types of controllers utilise detailed motion models of the system, based on system dynamics. They consider forces and torques acting on the system, as well as any disturbances (incorporated into the dynamic model). Therefore, these types of controllers have an advantage over kinematic controllers due to the unrestricted Operational Design Domain (ODD), but they incur higher computational complexity due to the complex calculations involving detailed models at each timestep.  In the following sections, we will discuss the most well-known model-free controllers, including PID and Stanley controllers, and then formulate the kinematic model of an intelligent vehicle for model-based control systems. PID Control  PID control represents a vast area within the field of control systems, meriting numerous classes on this singular subject matter alone. You already know how PID control operates and how we can design a PID controller. In this lecture, however, we will delve into designing a PID controller specifically for controlling the motion of an intelligent vehicle. The approach we 
Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah   will explore has been adopted by many intelligent vehicle manufacturers, including Google Waymo, offering a glimpse into the essence of automotive control. Consider the following problem: a car equipped with a steerable front axle and two non-steerable rear wheels needs to follow the reference line shown in Figure 1, which is the output from the previously discussed motion planner. Assuming the car maintains a constant forward speed, but you have the capability to adjust the steering angle, how would you proceed? Would you keep the steering angle constant? Would you issue random steering commands? Alternatively, you could adjust the steering angle in proportion to the "cross-track error" (CTE), which is the lateral distance between the vehicle and the reference trajectory. The optimal strategy involves steering in proportion to the cross-track error. The larger the error, the more the steering should adjust towards the target trajectory, decreasing as the vehicle approaches the trajectory. Clearly, maintaining a constant steering angle would only lead the vehicle in circles, not along a straight line, while random steering commands would be dangerous.   
 Figure 1 The concept of trajectory tacking (motion) control. The 'P-controller', where 'P' stands for proportional, represents the simplest form of a controller. Hereâ€™s a thought-provoking question that tests your intuitionâ€”it doesnâ€™t have a unique answer, but there is a best one. Suppose you steer the car in proportion to the cross-track error, as shown in Equation 1:   ğ›¿=ğœ!â‹…ğ¶ğ‘‡ğ¸ (1)  This means your steering angle is determined by multiplying the cross-track error by a factor of ğœ!. What outcome would this approach likely yield? Does the car never quite reach the reference trajectory, does it overshoot, or could either outcome occur? The answer, interestingly, is that it tends to overshoot. The issue is that, regardless of how small the constant, ğœ! in Equation 1 might be, it eventually causes significant wheel adjustment toward the trajectory. As the vehicle approaches this trajectory, and even as it aligns with it, the carâ€™s orientation will still be slightly off, compelling it to overshoot. This demonstrates that a P-controller, when applied to a car, causes overshoots. Although these might be minor and potentially manageable, the system never truly stabilises but remains 'marginally stable' or, as often referred in literature, 'stable.' The next pertinent question is, 'Is there a way to avoid the overshoot?' Ideally, yes, because experiencing oscillation while driving is unpleasant and can induce discomfort. The solution lies in 'PD-control.' In PD-control, the steering angle, ğ›¿, is influenced not only by the cross-track error through the gain parameter ğœ! but also by the temporal derivative of the cross-track error as:   ğ›¿=	âˆ’ğœ!.ğ¶ğ‘‡ğ¸âˆ’ğœ".##$(ğ¶ğ‘‡ğ¸) (2) 

Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah    This means that as the car effectively reduces the cross-track error, it anticipates the reduction, facilitating counter-steering. This enables a more graceful alignment with the target trajectory, given the correct adjustment of the differential gain ğœ" relative to the proportional gain ğœ!. How to compute the derivative of the cross-track error in Equation 2? At any given time ğ‘¡, this is calculated as the difference between the cross-track error at time ğ‘¡ and the cross-track error at time ğ‘¡âˆ’1, divided by the time interval between ğ‘¡ and ğ‘¡âˆ’1. The mathematical formulation is as follows:   ##$(ğ¶ğ‘‡ğ¸)=%&'!(%&'!"#)$ (3)  Now, we control not just in proportion to the error itself but also in relation to the change in error, using a second constant, ğœ".  Can the differential term alone solve the problem of achieving perfect trajectory alignment? The answer is no. Why is that? Consider driving a car where your usual steering adjustments lead you significantly astray from the desired trajectory. Over time, you notice the vehicle doesn't get closer to the goal, prompting you to increasingly correct your steering to the right to offset this bias. This requires a consistent situation of a large error, which is captured by the integral or the sum of the cross-track errors over time. Let's introduce a new controller type, where steering is still proportional to the cross-track error and its differential, but now it also includes a term proportional to the integral or the sum of all observed cross-track errors. This integral term is particularly interesting. If we have a constant cross-track error of, for example, 0.8, the sum will increase by 0.8 with each time unit, growing larger and larger, and eventually, it will correct the vehicle's motion. This introduces the PID controller, encompassing the Proportional (P), Integral (I), and Differential (D) terms. Implementing this, the integrated cross-track error is the cumulative sum of all cross-track errors observed. The mathematical representation of PID controller is:   ğ›¿=âˆ’ğœ*.ğ¶ğ‘‡ğ¸âˆ’ğœ".##$(ğ¶ğ‘‡ğ¸)âˆ’ğœ".âˆ«(ğ¶ğ‘‡ğ¸)ğ‘‘ğ‘¡ (4)  Initially, the gains of the PID controller need to be manually tuned. A general rule of thumb is to start with the ğœ+ and ğœ" values set to zero and adjust the ğœ* value until the system begins to oscillate around the setpoint. Then, the ğœ" value is fine-tuned until the oscillations are mostly damped out. Finally, the ğœ+ value is adjusted to minimise any steady-state error. To further refine the gains, an optimisation algorithm (such as twiddle or gradient descent) can be used for iterative adjustments. The characteristics of the controller gainsâ€”namely, the effects of gain amplification on the closed-loop system response for the proportional, integral, and derivative terms of the PID controllerâ€”are summarised in Table 1. This information is invaluable for tuning the controller gains to achieve the desired system response.        In essence, the P controller aims to correct the present error with a control action proportional to it. The I controller addresses any accumulated past error with a control action proportional to the cumulative error over time. The D controller anticipates future error by generating a control action proportional to the rate of change of the error. It is important to note that the 
ğœ"=0 ğœ+=0 ğœ*	â†‘ 
ğœ"â†‘ ğœ+=0 ğœ*:		ğ‘“ğ‘–ğ‘¥ğ‘’ğ‘‘ 
ğœ":	ğ‘“ğ‘–ğ‘¥ğ‘’ğ‘‘ ğœ+			â†‘ ğœ*:		ğ‘“ğ‘–ğ‘¥ğ‘’ğ‘‘ Table 1. PID Tunning 
Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah   integral and derivative controls are not standalone; they are designed to complement the proportional control. Stanley control Stanley controller is a geometric trajectory tracking controller developed by Stanford Racing Team for their autonomous vehicle â€œStanleyâ€ at the DARPA Grand Challenge (2005). Stanley controller uses both heading as well as cross-track errors to determine the steering action. As shown in Figure 2, the cross-track error CTE is defined with respect to a closest point on the reference trajectory whereas the heading error ğ‘’, is defined using the vehicle heading relative to the reference trajectory.  
 Figure 2 State configuration for Stanley control.  If we consider the centre of the front axle of the vehicle as the frame of reference, we have the geometric relations as shown in Figure 2, where, the vehicle wheelbase is ğ¿, forward velocity of the ego vehicle is ğ‘£- , and steering angle of the intelligent vehicle is ğ›¿.  Stanley controller uses both heading as well as cross-track errors to determine the steering command. It is noted that the steering angle generated by the controller must observe the steering actuation limits. Stanley control law is essentially defined to meet three requirements.  The first requirement of Stanley controller, as represented in Equation (5), is to correct the heading error by producing a steering control action ğ›¿ proportional (or equal) to it, such that vehicle heading aligns with the desired heading.    ğ›¿=ğ‘˜,ğ‘’,	 (5)  The second requirement is to correct the cross-track error by producing a steering control action ğ›¿ directly proportional to it and inversely proportional to the vehicle velocity ğ‘£- in order to achieve simultaneous control of longitudinal and lateral motions of the car. In Stanley controller, the effect for large cross-track errors is limited by using an inverse tangent function:   ğ›¿=tan(.>/$%&.%&'1'? (6)   By closely looking at the Equation (6), there is a practical problem in implementation of the controller. In fact, the inverse relation between steering angle and vehicle speed can cause numerical instability in control actions. At lower speeds, the denominator becomes small which causes the steering command to shoot to higher values, which is undesirable considering human comfort. Hence, an extra softening coefficient may be used in the denominator as an additive term in order to keep the steering commands smaller for smoother steering actions. On the contrary, at higher velocities, the denominator becomes large making the steering 

Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah   commands small to avoid large lateral accelerations. However, even these small steering actions might be high in some cases which causes high lateral accelerations. Therefore, an extra damping coefficient may be used in order to dampen the steering action proportional to vehicle velocity. Therefore, the modified control formulation is:   ğ›¿=tan(.>/$%&.%&'/(2/).1'? (7)   The third requirement is to continuously observe the steering actuation limits [âˆ’ğ›¿345,ğ›¿345] and clip the steering command within these bounds. Using these three requirements, we can formulate the complete Stanley control law.    ğ›¿=ğ‘˜,ğ‘’,+tan(.>/$%&.%&'/(2/).1'?;	ğ›¿âˆˆ[âˆ’ğ›¿345,ğ›¿345,]	 (8) It is noted that Stanley controller acts as a geometric proportional controller of steering angle ğ›¿ operating on the heading error as well as the cross-track error, while observing the steering actuation limits.  Using Equation (8), two important inputs for the Stanley controller are the heading angle error and the cross-track error. Now, the question arises: how can these inputs be calculated? The equations for the errors are as follows:   ğ‘’,=ğœƒâˆ’ğœƒ67- (9)  ğ¶ğ‘‡ğ¸=ğ‘¦âˆ’ğ‘¦67- (10)  In fact, the heading angle error is the difference between the actual heading angle of the car and the reference heading angle, which is calculated from the reference trajectory. Similarly, the cross-track error is the difference between the actual lateral position of the car and the reference lateral position. However, the reference trajectory provided by the motion planner is in Frenet coordinates, while the vehicle's sensor measurements are in Cartesian coordinates. Therefore, the reference trajectory in Frenet coordinates needs to be transformed into Cartesian coordinates. Transforming from Frenet coordinate into Cartesian coordinates is not trivial. The details of the transformation procedure are beyond the scope of this lecture, but final relations will be discussed. 
 Figure 3 Transformation from Frenet frame to Cartesian frame. 

Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah   When in the Cartesian frame, we can describe the current state of the ego vehicle as [ğ‘¥âƒ—,ğœƒ5	,ğœ…5,ğ‘£5,ğ‘5], where ğ‘¥âƒ— represents the vehicleâ€™s position at ğ‘„(ğ‘¥,ğ‘¦), and ğ‘›Mâƒ—ğ‘¥ and ğ‘¡âƒ—ğ‘¥ are the unit normal and tangent vectors of the vehicleâ€™s motion trajectory at the position ğ‘„ (see Figure 3). Additionally, ğœƒ5 denotes the angle between ğ‘¥âƒ— and the x-axis, ğœ…5 represents the curvature at ğ‘„, ğ‘£5 is the velocity of the ego vehicle, and ğ‘5 is the vehicleâ€™s acceleration. On the other hand, in a Frenet frame, the point ğ‘ƒ represents the projection of the vehicleâ€™s position point ğ‘„ onto the reference line. The angle between ğ‘Ÿâƒ— and the x-axis is denoted by ğœƒ6, while	ğ‘›Mâƒ—6 and 	ğ‘¡âƒ—6 denote the unit normal and tangent vectors of the reference line at point ğ‘ƒ. The vehicleâ€™s status can typically be described using the vector [ğ‘ ,ğ‘ Ì‡,ğ‘ Ìˆ,ğ‘‘,ğ‘‘Ì‡,ğ‘‘Ìˆ,ğ‘‘8,ğ‘‘"] where the distance between ğ‘ƒ and ğ‘„ corresponds to the transverse displacement ğ‘‘, and the curve distance from the start point of the reference line to ğ‘ƒ represents the longitudinal displacement ğ‘ . Additionally, ğ‘‘â€² denotes the first derivative of ğ‘‘ with respect to ğ‘  while ğ‘‘" denotes the second derivative of ğ‘‘ with respect to ğ‘ . Then, the equation of vehicle status in the Cartesian frame can be written as follows:   
  (11) Where âˆ†ğœƒ	=	ğœƒğ‘¥	âˆ’	ğœƒğ‘Ÿ; ğœ…ğ‘Ÿ is the curvature at point P. Kinematic Model-based Motion Control Kinematics is the study of motion of a system disregarding the forces and torques that govern it. Kinematic models can be employed in situations wherein kinematic relations are able to sufficiently approximate the actual system dynamics. It is important to note, however, that this approximation holds true only for vehicles that perform non-aggressive manoeuvres at lower speeds. To quote an example, kinematic models can nearly-accurately represent a vehicle driving slowly and making smooth turns. However, if we consider something like a racing car, it is very likely that the kinematic model would fail to capture the actual system dynamics.  In this part of lecture, the most widely used kinematic model for intelligent vehicles, the kinematic bicycle model, will be introduced. This model performs well at capturing the actual vehicle dynamics under nominal driving conditions. In practice, this model tends to strike a good balance between simplicity and accuracy and is therefore widely adopted. The idea is to define the vehicle state configuration and see how it evolves over time based on the previous state and current control inputs given to the vehicle.  Letâ€™s define the vehicle state configuration as ğ‘¥ and ğ‘¦ components of position and heading angle or orientation. Summarising, the intelligent vehicle state vector ğ‘ as this:    ğ‘=[ğ‘¥ğ‘¦			ğœƒ] (12)  For control inputs, we need to consider both longitudinal (throttle and brake) and lateral (steering) commands. The brake and throttle commands contribute to longitudinal accelerations in range of [âˆ’ğ‘ğ‘šğ‘ğ‘¥,ğ‘ğ‘šğ‘ğ‘¥] where negative values represent deceleration due to braking and positive values represent acceleration due to throttle (forward or reverse depending upon the transmission state). Note that the limits [âˆ’ğ‘ğ‘šğ‘ğ‘¥,ğ‘ğ‘šğ‘ğ‘¥] are intentionally denoted so as to distinctly illustrate the difference between the physical limits of acceleration 

Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah   due to throttle and deceleration due to braking. The steering command alters the steering angle Î´ of the vehicle, where ğ›¿	âˆˆ	[âˆ’ğ›¿ğ‘šğ‘ğ‘¥,ğ›¿ğ‘šğ‘ğ‘¥] such that negative steering angles dictate left turns and positive steering angles otherwise. Note that generally, the control inputs are clamped in the range of [âˆ’1,1] based on the actuators for proper scaling of control commands in terms of actuation limits. However, in this kinematic model, the longitudinal control is ignored, and the focus is on vehicle lateral dynamic control. Therefore, the intelligent vehicle control vector ğ‘¢ is defined as ğ‘¢	=ğ›¿. Before deriving the equations, letâ€™s define the parameters of the vehicle bicycle model as shown in Figure 4: ğ‘£ represents vehicle longitudinal speed, ğ›¿ is the vehicle wheel steering angle, ğœƒ	is the vehicle heading angle, ğ¿ is vehicle wheel-base, ğ‘™- and ğ‘™6 are the distances of front and rear axles to the vehicle centre of gravity, respectively. ğ‘£.sinğœ“ and ğ‘£.cosğœ“ are the velocity vector ğ‘£ into x and y components, respectively. ICR represents the vehicle instantaneous centre of rotation and R is the radius of the rotation. In this kinematic model, we assume no slip between tyres and the road.   
 Figure 4 Vehicle kinematic bicycle model.  Now letâ€™s derive the equations for kinematic model. First, resolving the velocity vector ğ‘£ into ğ‘¥ and ğ‘¦ components using the laws of trigonometry one obtains,    ğ‘¥Ì‡=ğ‘£.cosğœƒ	 (13)  ğ‘¦Ì‡=	ğ‘£sinğœƒ (14)  In order to compute ğœƒÌ‡, we first need to calculate R using this relation.   ğ‘…=9:;<(>) (15)   Now, we can deduce ğœƒÌ‡ as:   ğœƒÌ‡=1@=1.:;<(>)9  (16) 

Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah    We can formulate the continuous-time kinematic model of our intelligent vehicle in a vector format1:   ğ±Ì‡=ağ‘¥Ì‡ğ‘¦Ì‡ğœƒÌ‡b=cğ‘£.cosğœƒğ‘£.sinğœƒ1.:;<(>)9d (17)  After obtaining the equations for the kinematic model, we can now design a control system to enable the vehicle to follow the reference trajectories provided by the Motion Planning module using methods such as jerk minimisation. However, Equation (17) includes nonlinear functions, which make the control design non-trivial. To linearise the state equations, we can assume small angles for both heading and wheel steering. With this assumption, we have: cosğœƒâ‰…1, sinğœƒâ‰…ğœƒ and tanğ›¿â‰…ğ›¿. Therefore, the linearised dynamic model is:     ağ‘¥Ì‡ğ‘¦Ì‡ğœƒÌ‡b=cğ‘£.ğœƒğ‘£.ğœƒ19.ğ›¿d (18)  The kinematic model can be rewritten in matrix format, based on its inputs and states, as follows:   ağ‘¥Ì‡ğ‘¦Ì‡ğœƒÌ‡b=a00000ğ‘£000b  fğ‘¥ğ‘¦ğœƒg + c0019d ğ›¿+ fğ‘£00g (19)  The compact representation of the kinematic model is:   ğ±Ì‡(ğ‘¡)=ğ´(ğ‘£)ğ±(ğ‘¡)+ğµ.(ğ‘£)ğ‘¢(ğ‘¡)+ğµA(ğ‘£) (20)   The obtained linear model is a time-vary system as the system matrix, ğ´ and input vector ğµ. are function of vehicle speed. To design a control system using the kinematic model represented by Equation (20), we need to use the advanced control techniques. To make the control design problem simpler, we can assume that the vehicle speed is constant. In this case, the kinematic model will be time-invariant and therefore, we can ignore the longitudinal dynamic. In this case, Equation (20) can be simplified as:    ğ±Ì‡(ğ‘¡)=jğ‘¦Ì‡ğœƒÌ‡k=fğ‘£.	ğœƒ19ğ›¿g (21) or   jğ‘¦Ì‡ğœƒÌ‡k=l0ğ‘£00mlğ‘¦ğœƒm+ f019g ğ›¿ (22)  Then the compact matrix representation of Equation (22) is:  1 Please note, the parameters presented in lowercase, non-italic, bold format represent vectors. Those in lowercase, italic, but not bold, represent scalars, and those in uppercase, italic, but not bold, represent matrices. 
Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah    ğ±Ì‡(ğ‘¡)=ğ´ğ±(ğ‘¡)+ğµğ‘¢(ğ‘¡) (23)  ğ²=ğ¶ğ±(ğ‘¡) (24) Where, ğ² is the output vector:   ğ’š=lğ‘¦ğœƒm=l1001mlğ‘¦ğœƒm (25) The objective is to design a controller that minimises the error between the reference trajectory and the actual vehicle trajectory. Therefore, the first step is to define the error vector ğ(ğ‘¡) as:    ğ(ğ‘¡)=ğ±(ğ‘¡)âˆ’ğ±67-(ğ‘¡)  (26) where, ğ±67-(ğ‘¡) is the reference trajectory, and ğ±(ğ‘¡) is the actual vehicle state. The derivate of error vector is:  ğÌ‡(ğ‘¡)=ğ±Ì‡âˆ’ğ±Ì‡67-  (27) By substituting Equation (23) into Equation (27), we have:  ğÌ‡(ğ‘¡)=ğ´ğ±(ğ‘¡)+ğµğ‘¢(ğ‘¡)âˆ’ğ±Ì‡67-(ğ‘¡) (28) By rearranging Equation (26), we can calculate state vector based on error vector as:  ğ±(ğ‘¡)=ğ(ğ‘¡)+ğ±67-(ğ‘¡) (29) By substituting ğ±(ğ‘¡) into Equation (28), we have:  ğÌ‡(ğ‘¡)=ğ´ğ(ğ‘¡)+ğµğ‘¢(ğ‘¡)+ğ´ğ±67-(ğ‘¡)âˆ’ğ±Ì‡67-(ğ‘¡)  (30) where, ğ´ğ±67-(ğ‘¡)âˆ’ğ±Ì‡BCD(ğ‘¡) represents how the reference trajectory inherently changes over time (and assuming it does not directly depend on the system's state ğ±(ğ‘¡) or the control input ğ‘¢(ğ‘¡)). The term ğ´ğ±67-(ğ‘¡)âˆ’ğ±Ì‡BCD(ğ‘¡) can be seen as an external input or disturbance to the error dynamics, influenced by the trajectory's predefined behaviour. Therefore, a more nuanced view is that the control law needs to counteract not just the state ğ±(ğ‘¡) deviations from ğ±67-(ğ‘¡) but also the rate at which ğ±67-(ğ‘¡) itself changes. Therefore, we need two controllers, one is the feedback control and another is feedforward control. The feedback control is responsible for compensating for any deviations from the reference trajectory by adjusting the input (steering angle) based on the error while the feedforward controller aims to anticipate the reference trajectory and provide the necessary input to follow it precisely. Therefore, the control law will be:  ğ‘¢(ğ‘¡)=âˆ’ğŠğ(ğ‘¡)+ğ‘¢EE (31) where, =âˆ’ğŠğ(ğ‘¡) is the feedback control law and ğ‘¢EE is the feedforward control. Therefore, the error dynamics equation will be:  ğÌ‡(ğ‘¡)=ğ´ğ±(ğ‘¡)+ğµ[âˆ’ğŠğ(ğ‘¡)+ğ‘¢EE]+ğ´ğ±67-(ğ‘¡)âˆ’ğ±Ì‡67-(ğ‘¡) (32) 
Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah   We can design the feedback controller, ğŠ, using different feedback control techniques such as pole placement, optimal control or model predictive control (MPC). The calculation of the feedforward control term, ğ‘¢EE, is a crucial aspect of ensuring the vehicle precisely follows the reference trajectory. This term is designed to anticipate the necessary control actions to maintain the trajectory, considering the inherent changes in the trajectory over time. Specifically, ğ‘¢EE is calculated by isolating the feedforward term in the control law equation and ensuring the system's error dynamics are addressed in the steady-state condition (where ğ‘’(ğ‘¡)â†’0 as ğ‘¡â†’âˆ). Therefore, in steady state condition, we have:  ğŸ=ğŸ+ğµ[ğŸ+ğ‘¢EE]+ğ´ğ±67-(ğ‘¡)âˆ’ğ±Ì‡67-(ğ‘¡)  (34) By reshaping above equation, the feedforward controller can be formulated as:  ğ‘¢EE=ğµ(ğŸuğ±Ì‡67-(ğ‘¡)âˆ’ğ´ğ±67-(ğ‘¡)v (35) where, ğµ(. represents the inverse of the input matrix B, enabling us to compute the direct influence of the reference trajectoryâ€™s dynamics on the control input. In essence, ğ‘¢EE functions to proactively adjust the vehicle's steering angle according to the planned changes in the reference trajectory, rather than reacting to deviations after they occur. This proactive approach is fundamental in achieving smoother and more accurate trajectory tracking, especially in scenarios where the vehicle's dynamics and the desired trajectory involve complex manoeuvres or rapid changes in direction. Model Predictive Control  Model Predictive Control (MPC) is a type of optimal control strategy that basically treats the control task as a constrained or bounded optimisation problem. MPC is a powerful method for designing motion control systems for intelligent vehicles and has been widely used by industry.  But how MPC works? Model predictive controller predicts the future states of the vehicle up to a certain prediction horizon using the motion model and then solves an online optimisation problem considering the constraints or control bounds in order to select the optimal set of control inputs by minimising a cost function such that the future state(s) of the intelligent vehicle closely align with the goal state (as required for trajectory tracking).  In other words, given the current state and the reference trajectory to follow, MPC involves simulating different control inputs (without actually applying them to the system), predicting the resulting future states (in form of a predicted trajectory) using motion model up to a certain prediction horizon, selecting the optimal set of control inputs corresponding to minimal cost trajectory (considering constraints) at each step in time, and applying the very first set of optimal control inputs (up to a certain control horizon) to the intelligent vehicle, discarding the rest. With the updated state, we again repeat the same algorithm to compute a new optimal predicted trajectory up to the prediction horizon. In that sense, we are computing optimal control inputs over a constantly moving prediction horizon. Thus, this approach is also known as receding horizon control. Figure 5 depicts the structure of an MPC controller.  
Intelligent Vehicle Design (ENGM298) â€“ Prof Saber Fallah    Figure 5 The structure of MPC.  

