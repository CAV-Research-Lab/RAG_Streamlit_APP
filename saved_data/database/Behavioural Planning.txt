=== Metadata ===
{
    "file_name": "Behavioural Planning.pdf",
    "file_path": "/Users/mf0016/Desktop/soe_RAG/resources/Behavioural Planning.pdf",
    "status": "Processed"
}

=== Content ===
Intelligent Vehicle Design (ENGM298) ‚Äì Prof Saber Fallah  Behavioural Planning Introduction to Behavioural Planning  The focus of this part of lecture is on Behavioural Planning, a key element that serves as a crucial link between a vehicle's understanding of its surroundings and its actions within that context. Let's begin by reviewing again the interlinked functionalities of autonomous driving of an intelligent vehicle (Figure 1). This begins with Sensing, the very foundation of our vehicle's interaction with the world. The vehicle's sensors perceive the environment around the vehicle, identifying other vehicles, pedestrians, road signs, and more. This raw sensor data is then processed by the Perception system, which creates a structured understanding of the environment. Localisation uses this understanding, combined with mapping data, to precisely determine the vehicle's position in the world. Armed with this information, Prediction anticipates the potential actions of other road users in the vehicle's vicinity. With the groundwork laid by Sensing, Perception, Localisation, and Prediction, our vehicle has a clear and current understanding of its surroundings, and the actions other road users might take. Then, Mission Planning establishes high-level objectives for the journey, such as the destination and optimal path to reach it, factoring in elements like the road network and traffic conditions. This is where Behavioural Planning comes into play. This pivotal functionality determines the vehicle's moment-to-moment actions based on the mission and current understanding of the world. Questions like 'Should we change lanes?', 'Should we slow down due to the pedestrian ahead?' are answered by Behavioural Planning. These decisions are then converted into a specific, safe path by Motion Planning, and Motion Control executes these plans, physically manoeuvring the vehicle as per the desired trajectory. In essence, Behavioural Planning translates the vehicle's understanding of its environment - gathered and processed through Sensing, Perception, Localisation, and Prediction - into actions that move it closer to its mission, ensuring safety and adherence to traffic rules along the way. Today, we'll delve into the intricacies of Behavioural Planning, exploring how it endows an intelligent vehicle with the intelligence to 'behave' and make decisions just like a human driver.  
 Figure 1 The interlinked functionalities of autonomous driving of an intelligent vehicle. How It Works? Imagine you are driving in a city with your friend. You have a destination that you are trying to get to. You are sitting in the passenger seat and your friend is driving. You plug that destination into Google Maps, and you get some route that will get you to your destination. The driver should not be worried about the details of what the route exactly is, because the driver trusts that you, as the navigator, provide the necessary driving instructions. It is understood that they 

Intelligent Vehicle Design (ENGM298) ‚Äì Prof Saber Fallah  are solely in charge of execution. In this situation, the responsibilities of the passenger are similar to the responsibilities of a behaviour planner in an intelligent vehicle. So, if you tell your friend to go left, they will do that. And when you tell the driver to pass a slow vehicle, the driver will not worry about whether they have enough time to do so because they will assume that you have thought about that and that you are confident that they can make it. But the navigator is not responsible for safety. If you tell the driver to get back to the left lane but there is a vehicle in the way, you will assume that they will wait to move left until there is enough room to do so safely. The navigator will also tell the driver when to keep their lane and when it is time to turn or change lanes or maybe adjust the speed. And finally, once you are arrived at your destination, you will tell the driver to stop. Now, let‚Äôs have a closer look at the behaviour planner. The behaviour planner is currently a black box which takes as input a map of the world, a route to the destinations, and predictions about what other static and dynamic obstacles are likely to do, and it produces as output an adjusted manoeuvre for the vehicle which the motion planner is responsible for reaching collision-free, smooth, and safe (see Figure 2).  
 Figure 2 Inputs and output of the behavioural planner The aim of this lecture is to understand this black box and learn how to implement a behaviour planner. Therefore, the responsibilities of the behavioural planner module are to suggest manoeuvres which are feasible, as safe as possible, legal, and efficient. What the behaviour planner is not responsible for are execution details and collision avoidance. The approach to behavioural planning which you are going to learn in this lecture is an approach which is the same one used by most of the vehicles, including the winning one in the DARPA Urban Challenge and Bertha Benz Drive. The method is capable of handling complex traffic situations like navigating intersections and dense urban traffic. While the approach is not necessarily the most common anymore, for reasons that will be discussed later, it is widely known in the field, and it does give a very high-level understanding of what is going on in a behaviour planner. In the example that was discussed above, the navigator gave various suggestions about what to do next and the instructions they gave were about things like changing lanes, follow a lane, turning and so on. But in fact, there really are not that many types of suggestions you would expect to hear from a navigator. In this lecture, you learn an approach to behaviour planning, called Finite State Machine, to solve the behaviour planning problem. A Finite State Machine makes decisions based on a finite set of discrete states. In Figure 3 for example there are five discrete states. When initialised, a finite state machine begins in some start state, let's call it ùëÜ!. Any pair of states within the finite state machine can be connected by one or more transitions. Sometimes there is a transition back to the same state which is called a self-transition. Not all transitions are necessarily possible. For example, S4 does not transition to any other state. In the language of finite state machines this would be called an accepting state. For non-accepting states there are often multiple potential successor states. To decide which state to transition to next, a finite state machine needs to handle the input(s) and then use a state transition function to decide what state to go next. You will learn more about transition functions and the states associated with an intelligent vehicle, but first, let‚Äôs formalise what a finite state machine is, with the help of a simple example.  

Intelligent Vehicle Design (ENGM298) ‚Äì Prof Saber Fallah   Figure 3 An example of a finite state machine with five discrete states Formalising Finite State Machine   Let's consider a simple vending machine where everything costs 20 pence, and let's say that this vending machine only takes 5p and 10p coins but no other coins. Then we can model the state of this vending machine by the amount of money that is been deposited. The start state would be zero pence, and from this state there are two things that can happen. We could put in a 5p coin, which would make the state five pence, or we could put in a 10p coin to take the state to 10 pence. The rest of the transitions are straightforward until we think about what to do if we are in the 15 pence state and someone puts in a 10p coin. We could just count that as 20 pence. But let's say that this machine requires exact change so that a 10p coin would just fall through and come out of the little tray at the bottom of the machine. As you can see, finite state machines are straightforward conceptually. However, they have their strengths and weaknesses. Let's start with their strengths. First, finite state machines are very easy to reason about. They are basically self-documenting because they map the logical state of a system directly to the physical state. When a 5p coin goes into the vending machine the state changes to the state that is five pence bigger than the current one. Next, they are maintainable. If we wanted to tweak this machine such that everything costs 25 pence, it would be trivial to just add one more state. Now let‚Äôs talk about the weaknesses of the finite state machine. The primary one being that they are easily abused. If they are not designed well to begin with or if the problem changes you can easily find yourself saying things like, I hadn't considered that. Let's just add another state and this can lead to some messy code and messy logic, which in practice means that finite state machines can be very difficult to maintain as the state space gets bigger.  
 Figure 4 Vending machine example 

Intelligent Vehicle Design (ENGM298) ‚Äì Prof Saber Fallah  State For Intelligent Vehicles   When we are thinking about a simple vending machine it is easy to enumerate the states. Now let's consider the states we may want to model for the car driving on a highway. The first step is to throw out all the ideas that one can come up with and then prune the list afterwards. Let's keep it simple first. What happens if we are the only car on the road? We would need a state for normal staying in current lane driving. If we are changing lanes, we want a state to represent that. Or maybe two states since changing lanes to the left is different than to the right. Now, what changes if there is a vehicle in front of us?  We might want to stay behind it, so we should have a state for that, or we might want to pass it. But pass is just a lane-change to the left and then a lane-change to the right, therefore, do we really need a state for that? Let‚Äôs for now consider all possible states that we can think of. Now, what changes if we had more cars? One could imagine in this situation the car might want to slow down so that it could merge into the gap between the cars in the other lane and then pass the car if it is going slow. We should have a slow-down state which means we will also need a speed-up state. We should probably add a stop state in case there is some emergency. We could do all of that at once by having a keep target speed state. But speed is just dictated by the lane you are driving in and the speed limit. What if we just add a prepare lane change state to represent when the ego vehicle is trying to go next to an empty gap in traffic before a lane change? We should also have a prepare lane change left and to prepare a lane change right. We can also think of other states, for example, we could consider turn on the turn-signals down. The truth is there is not a single correct set of states to choose from. On one hand we want to keep our state space as small as possible for maintainability reasons, but on the other hand we want to make sure we have enough logical states to actually represent all the physical states that we care about. As you have seen in this discussion, it is not easy to find the perfect set of states for the lane-change scenario. You may want to think what states you would want to use to represent vehicle behaviour on a highway. Check the boxes next to each state that you would keep and add any additional states that you think are important to the list.  Now let‚Äôs review what we discussed so far. At first, we chose highway driving scenario and then we debated what states we should use for our finite state machine. We quickly agreed on three, since it seemed to us like these were the bare minimum and that a single lane-change would not suffice. We also agreed to rule out a lot of states because most of these can be thought of as various implementations of the keep-lane state. But the last two, prepare lane-change-left and prepare lane-change-right, we were unsure about. Eventually, we did decide to use these two states. To describe the state finite machine for a highway driving scenario, let's start by imagining what vehicle behaviour would look like without two preparation states. In this case, we have a two-lane highway with traffic driving to the right.  When we only have three states plus a fourth ready state, the finite state machine looks like what is shown in Figure 5. Before explaining, let‚Äôs assume that there are two driving targets for each state, one is the vehicle direction or the lane ID that we show as small letter ‚Äúd‚Äù and another one is the vehicle target speed which we show it as small letter ‚Äús‚Äù. Now assume that our intelligent vehicle is already in the ‚Äúkeep lane‚Äù state. Before we think what happens to our vehicle when it uses this finite state machine, let‚Äôs think what these states mean. The ‚Äúlane-keep‚Äù state attempts to stay in the current lane by staying near the centre line for that lane. Therefore, thinking in finite coordinates, we might just say that target ‚Äúd‚Äù for the vehicle is whatever the ‚Äúd‚Äù for the lane is. And for the ‚Äús‚Äù direction, ‚Äúkeep-lane‚Äù state attempts to drive at the vehicle's target speed when it is feasible, but when it is not, it will try to drive at whatever speed is safest for the lane. 

Intelligent Vehicle Design (ENGM298) ‚Äì Prof Saber Fallah   
 Figure 5 Finite state machine representation for highway driving scenario without preparation states. For lane changes the goal is to move from the initial lane to the target lane. The ‚Äúd‚Äù behaviour is what you might expect to move left or right as appropriate. therefore, the target ‚Äúd‚Äù is the ‚Äúd‚Äù for whatever lane is to the left or right of the ego's current lane. For ‚Äús‚Äù, the same rules as lane keeping apply. The vehicle will try to drive at the target speed, but if it is not feasible, then it will drive at whatever speed is safe for the initial lane. Here are the definition of states for this highway driving scenario: Lane Keep:  ¬ß d - stay near centre line for lane ¬ß s - drive at target speed when feasible, otherwise ‚Ä¶ o d ‚Äì stay near canter line for lane Lane change left/right:  ¬ß d - move left or right ¬ß s - same rules as keep lane (for initial lane)   Even though the above description of states works, there are some problems. First, even when there is a gap that the car can probably move into, we have no way to tell the vehicle to try to get alongside that gap. We had to just wait for the gap to get close to us. Second, the lane-change is not completely safe. Ideally, we would have been able to get closer to the lane-speed before making the lane-change. Third, it is not clear when we would have turned on the turn signal in this scenario. The turn signal is the responsibility of the behaviour team and ideally, we would like to turn it on a few seconds before we actually start changing lanes. Using this finite state machine, it would have been hard to do that. To address these problems, we can introduce a prepare for lane change state. In this state we do whatever we can to prepare for a lane change left or right, which means for the ‚Äúd‚Äù targets we still can stay in this current lane but for the ‚Äús‚Äù target we tried to match the position and speed of some gap in one of the adjacent lanes. In this state, at the first timestep we can decide to prepare for a lane change by tracking the gap between cars, which allows us to immediately start slowing down. At this point, the car may begin slowly increasing speed to get closer to the left lane speed, and at this point the vehicle has reached the same speed as the left lane traffic and is in a good position to execute a lane change. From here on, everything looks pretty like before. With these added states, we're now able to perform a lane change more safely and efficiently. Here are the additional states description to the abovementioned description: Prepare lane change left/right:  ¬ß d - stay near centre line for current lane ¬ß s - attempt to match position and speed of ‚Äùgap‚Äù in lane   

Intelligent Vehicle Design (ENGM298) ‚Äì Prof Saber Fallah  Can you complete the finite state machine graph shown in Figure 5 by adding prepare lane change left and right states to it? You just learnt how the states we choose to use can impact the behaviour of the vehicle. But deciding how those states transition and what inputs the transition functions use is crucial to the actual implementation of a finite-state machine. For the example with the vending machine, the only input was the coin. The intelligent car is more complicated. Therefore, the question is, what data will we need to pass into our transition function as input? Predictions of behaviour of other road users, map, speed limit and other legal constraints, localisation data and information of current states are essential inputs into the transition function. Create a Cost Function A key part of getting transitions to happen, when we want them to, is the design of reasonable cost functions. We want to penalise and reward the right things. Let's consider how we would design a cost function for vehicle speed. On one hand, we want to get to our destination quickly, but on the other hand, we do not want to break the law. An essential quantity we have to control is the desired velocity of the car. Some velocities are more beneficial, some are even illegal. Let's start assigning some costs to every velocity. For the sake of simplicity, let's assume that all of the cost functions will have an output between zero and one. We will adjust the importance of each cost function later by adjusting the weights. Let's say the speed limit for the road we are on is the point shown in Figure 6. We know that if we are going well above the speed limit, that should be maximum cost and maybe we want to set an ideal zero cost speed that is slightly below the speed limit so that we have some buffer. And then we can think about how much we want to penalise not moving at all. Obviously, not moving is dangerous, but maybe not as dangerous as breaking the speed limit, therefore, we would put the cost at the point on vertical axis (Stop Cost) shown in the Figure 6. To keep it simple, we could just say there is a linear cost between zero and the target speed. And since breaking the law is a binary thing, let's just say any speed greater than or equal the speed limit has maximal cost. And again, we can arbitrarily connect these points with a linear function and the flat maximum cost for anything above the speed limit. Now, in practice, we might actually want to parametrise some of these quantities so that we could later adjust them until we got the right behaviour. So first, we might define a parameter called Stop Cost for the zero-velocity case and a parameter called buffer velocity which would probably be a few miles per hour. Then, the overall cost function has three domains. If the vehicle speed is less than the target speed, the cost function would look like the ‚Äúif function‚Äù shown on the top-left of the figure. If the vehicle speed is above the speed limit, the cost is just one. And if the vehicle is within buffer velocity, the cost would look like the ‚Äúif function‚Äù shown in the bottom-right of the Figure 6. 
 Figure 6 Speed cost function design 

Intelligent Vehicle Design (ENGM298) ‚Äì Prof Saber Fallah  Example Cost Function - Lane Change Penalty In Figure 7, the blue intelligent car which is at bottom left is trying to get to the goal which is shown by gold star. It is currently in the correct lane, but the green car is going very slowly, so it considers whether it should perform a lane change (LC) or just keep lane (KL). These options are shown as lighter blue vehicles with a dashed outline.  
 Figure 7 Highway lane-change driving scenario If we want to design a cost function that deals with lane choice, it will be helpful to establish what the relevant variables are. In this case, we can define: ùõ•ùë†=ùë†"‚àíùë† : how much distance the vehicle will have before it has to get into the goal lane. ùõ•ùëë=ùëë"‚àíùëë#$/&#	: the lateral distance between the goal lane and the options being considered. In this case ùõ•ùëë&#=ùëë"‚àíùëë&# would be zero and  ùõ•ùëë#$=ùëë"‚àíùëë#$would not. Before we define an actual cost function, let's think of some of the properties we want it to have. First, thinking only about ùõ•ùëë:  Would we prefer the absolute value of ùõ•ùëë to be big or small? In general, we would prefer to be closer to the goal lane which means the cost should be bigger when ùõ•ùëë is bigger. Mathematically we can say: ‚Äúcosts associated with lane choice should be proportional to ùõ•ùëë‚Äù. Now let's think about how ‚Äús‚Äù factors into our considerations of lane cost.  Should costs associated with lane change be more important when we are far from the goal (in ‚Äús‚Äù coordinate) or close to the goal? You should note that when we are far from the goal, we have lots of time to get into the goal lane. As we get closer things get more urgent. Mathematically we can say "costs associated with lane choice should be inversely proportional to ùõ•ùë†. Thus, we want a cost function that penalises large ‚à£ùõ•ùëë‚à£ and we want that penalty to be bigger when ùõ•ùë† is small. Furthermore, we want to make sure that the maximum cost of this cost function never exceeds one and that the minimum never goes below zero. Therefore, in this case  ùê∂ùëúùë†ùë°=1‚àíùëí'|‚àÜ#|‚àÜ$	. Designing cost functions is difficult and getting them all to cooperate to produce reasonable vehicle behaviour is hard. Some of the difficulties associated with cost functions design include solving new problems without not solving old ones. When you are working on an intelligent vehicle, you may find that the vehicle is behaving reasonably well except for some particular situations. Maybe it is not being aggressive enough about making left turns at traffic lights. Thus, to solve this problem, you either add new cost functions, tweak existing ones, or modify the weights. But every time you do, there is a chance that you will introduce some breaking change into something that already works. In practice, we solve this through regression testing, where we define some set of situations, each of which has an expected behaviour. Then, whenever we make a change, we simulate the vehicle in all the test cases and make sure that it still behaves as expected. The testing procedure is out of scope for this lecture, but it is an important part of developing software in a safety-critical application like intelligent vehicles. 

Intelligent Vehicle Design (ENGM298) ‚Äì Prof Saber Fallah  The next difficulty is balancing costs of drastically different magnitudes. Because we want to get to our destination efficiently, but if we are in a situation where safety is an issue, we want to solve that problem and not think about efficiency at all. One way to do that is to have weights which reflect the type of problem that the cost function addresses. Hence, we want to most heavily penalise any behaviour which simply is not possible due to physics, then we want to think about safety, legality, and comfort. Only once those are satisfied, we want to think about efficiency. But we also may want to adjust the relative importance of these weights depending on situation. For instance, if a light turns red, legality becomes a much more relevant concern than when we engage in normal highway driving. This leads us to our last difficulty, reasoning about individual cost functions. Ideally, each cost function will serve a very specific responsibility, which is something we did not do in our earlier example of a speed cost function. We were trying to balance our desire to drive quickly, which has to do with efficiency, with our desire to not exceed the speed limit, which is legality. In practice, we might want to define several cost functions associated with vehicle speed. In which case we might have a binary cost function which just checks to see if we are breaking the speed limit and the continuous cost function which pulls us towards our target speed. By assigning each cost function to a very specific role, like safety versus legality versus efficiency, we can then standardise the output of all cost functions to be between -1 and 1. Additionally, it is helpful to parametrise whenever possible. This allows us to use some parameter optimisation technique like gradient descent along with the set of regression tests to programmatically tweak the cost functions. Finally, thinking in terms of vehicle state is helpful. The things we can indirectly control about our vehicle are its position, velocity, and acceleration. It can be helpful to keep these in mind when coming up with cost functions. Let's walk through an example. We want to think about a set of classes of cost functions for behaviour planning as shown in Figure 8. In order to make it easier and to keep everything straight, let's think in terms of position, velocity, and acceleration. The binary "Are we exceeding the speed?" cost function is about legality and its parameter is the vehicle speed, then the cost function that wanted to keep us close to the speed limit represent cost associated to driving efficiency. It is noted that instead of using weird discontinuous cost function shown in Figure 6, we can use a parabola function for efficiency cost function. Even though the cost of the parabola function is low even for speeds that exceed the speed limit, it is fine because we have the binary cost function which will prevent that behaviour. Continuing to think about speed, we also might want to try to drive at a speed which is close to the average speed of traffic, for safety reasons, even if that speed is above or below the speed limit. And that goes on the intersection of safety and velocity as shown in the table of Figure 8. In the position column, we would have an obvious feasibility concern which is collision avoidance. We cannot drive somewhere if there is already a car there. Then, for safety reasons, we would want the buffer distance, which tries to keep us far from other vehicles, and the cost function which checks to make sure we are driving on the road near the centre of our lane and in a lane which is close to our goal lane. For acceleration, we would first want to make sure we only consider behaviours that the car can execute, and then we would want to avoid having any rapid changes in acceleration because those are perceived as uncomfortable. This is also known as jerk which you will learn more about in the next lesson. Consider a merge onto a highway, for example. This is a potentially dangerous situation where we really want to get up to traffic speed as quickly as possible. Thus, this cost function may become more relevant than it normally is. But we also want to make sure that we yield if there is not a gap, therefore we want to ensure safety and efficiency cost functions are weighted sufficiently high. And we can compare these merge priorities to a different situation. For example, a car approaching a green light that suddenly turns yellow. In this situation, we probably want to boost the weights associated with legality and probably need to add a whole new cost function for obeying traffic rules.  If this is all starting to feel like it is getting complex, well, you are right. It is hard to avoid this exploding complexity when using finite state machines. Partially that is because of the finite 
Intelligent Vehicle Design (ENGM298) ‚Äì Prof Saber Fallah  state machine itself, but we are also trying to solve a very hard problem and some complexity is unavoidable no matter what solution approach you take. 
 Figure 8 A set of cost functions for behaviour planning.  Summary In this lecture, you learned about finite state machines which are a solution to the behaviour planning problem. To recap, a finite state machine is a computational model used to design sequences of operations in response to certain inputs. Essentially, it is a system that can be in one of a limited number of states at any given time, transitioning from one state to another based on predefined conditions. In the realm of intelligent vehicles, FSMs are invaluable for behavioural decision-making. For example, an intelligent vehicle might have states like "follow lane," "change lane," or "turn at intersection." As the vehicle perceives its environment, such as detecting a slow-moving car ahead or approaching an intersection, the FSM transitions from one state to another, dictating the vehicle's next action. Thus, FSMs offer a structured way for vehicles to make safe and logical decisions based on their surroundings and objectives. Finite state machines generally do well for small state spaces, like when you are on a highway, for example. For more complex scenarios like urban driving, other approaches might be more suitable. 

